;; This is the file of updates that speeds up the inference side of the matcher.
;; Based upon Dongkyu's Fast-Matcher code (version 3/20/08).
;; 
;; The premises for this update are as follows:
;; =============
;; The overall control strategy when inferring new beliefs will be to work through
;; the concept network alternating between the partially-ordered, non-looping areas
;; and the loops generated by the recursive concept definitions.  The control 
;; structure chooses a simple-and-fast bottom-up strategy for non-looping areas and
;; propagates as far as possible through the network until encountering a loop.  The
;; loop(s) will be propogated with as many passes as necessary of the same
;; simple-and-fast matcher.  After the loops, the controller will go back to 
;; single-pass propagating through more non-looping areas.  This is how the
;; alternating control will proceed until finished.

;; Top level control structure
;;  1) sort concept network and identify loops
;;  2) single pass bottom-up propagation&inference until finished or reached next loop
;;  3) if finished then end
;;  4) multiple-pass propagation for loop(s)
;;  5) iterate back to 2) for next loop-free section of concept network

;; When constructing new beliefs, all beliefs must make note of the beliefs/basic
;; percepts upon which they depend.  Each belief records all the base-level
;; percepts upon which it depends.  At the cycle boundary, the percepts that have
;; changed since the previous cycle are noted.  Only the beleifs depending on these
;; changed percepts are eliminated.  This differs from past strategies which 
;; eliminated all beliefs at the start of each cycle.  If beliefs change little then
;; this should give a large number of items to find quickly and at high levels of a
;; top-down search.

;; Details:
;; ======
;; We're planning to build upon the fast-matcher function.  The sort-concept-network
;; function will be updated to identify loops and then continue sorting as well as
;; possible through and beyond them.

;; For recording dependencies, beliefs will be changed to a defstruct definition.  
;; This change will also facilitate time-stamps and probabilities in the future.  
;; Function calls as used by goal-selection and skill-execution will not change.

;; Safety: variables appearing in head, or in a negative literal must also appear in a 
;; positive literal in the body
;; Stratification: starting from one relation p(x), one can never reach ~p(x) by following
;; rules backward
;; * applies to rules with a negation *

;; Icarus Safety: variables appearing in a negative literal in the body must appear in
;; the head, in the percepts field, or in a positive literal in the body.
;; Icarus Safety #2: binding of variables - universal vs existential when joined with negations


;; A belief will have bindings if the head of its concept has more than a name, 
;; i.e. if it has inputs
;; A belief will have dependencies if its concept has relations, else it will
;; have percepts based on its concept args, tests, and percepts fields
;; Both the immediate sub-beliefs (the relations) and the basic beliefs at the 
;; bottom of the tree are saved for retracking the dependencies when needed.
;; The last possibility is that the concept's percepts will name a constant
;; (rarther than a variable) and 
;; we need to test for equality/identity of that percept.


;;; This goal definition is here for use with the Tempe version of Icarus
;;; and is also found in (is taken from) Stanford's compiler module.  
;;; One version of CommonLisp, even with completely uncompiled code, 
;;; didn't update all code that used it with a simple re-definition found here.
;;;(defstruct goal type chaintype objective skills subgoals achieved intention
;;;           precursor sfailed cfailed path history)

; COMPILER.LISP updated to reflect this change. -Dongkyu
;(defstruct cinstance head id bindings subgoals (degmatch 1.0)
;                     (timestamp cycle*)
;                     pos-dependencies neg-dependencies percepts total-percepts)

#|(defun create-cinstance (concept bindings)
     ;;; ==> an belief to be stored in cstm* and the concept's instances
  (make-cinstance :head ;; (name val1 val2 ...) the values assoc'd w/variables in head
                  (subst-bindings bindings (concept-head concept))                  
                  :bindings bindings ; alist of (var . perc) where perc is from pstm* space
                  :pos-dependencies (get-pos-sub-heads concept bindings)
                  :neg-dependencies (get-neg-sub-heads concept bindings)
                  :percepts (get-percepts concept bindings) ; items from the pstm* space
                  ))
|#

(defun delete-belief (belief &optional (test #'same-cinstance))	; belief is a cinstance
  (setq cstm* (remove belief cstm* :test test))
  (let ((c (lookup (cinstance-id belief))))
    (unless (null c)
      (setf (concept-instances c)
            (remove belief (concept-instances c) :test test)))))

(defun same-concept (concept1 concept2) ; ignores differing variable names and gets siblings equal
  (and (equal (car (concept-head concept1)) (car (concept-head concept2)))
       (= (length (concept-head concept1)) (length (concept-head concept2)))))

#|(defun get-dependencies (concept bindings &optional (already-been-there nil))
  (let ((subs nil)
        (final nil))
    (setq subs (loop for sub in (get-subs concept)      ; filter out the looping concepts
                     if (not (member sub already-been-there :test #'equal))
                     collect sub))
    (loop for sub in subs
          doing (setq final (union final (get-dependencies sub bindings (cons sub already-been-there))
                                   :test #'equal)))
    final))
|#

(defun get-pos-sub-heads (concept bindings)
  (loop for sub in (concept-positives concept)
        collect (subst-bindings bindings sub)))

(defun get-neg-sub-heads (concept bindings)
  (loop for sub in (concept-negatives concept)
        collect (subst-bindings bindings sub)))
  
;; this func needs to get all the perceptions addressed by the args, 
;; by the test(s) and by the percepts field
(defun get-percepts (concept bindings)
  (let* ((flag nil)
         (test-vars (collect-test-vars (concept-tests concept)))
         (perc-vars (mapcan #'get-vars (concept-percepts concept)))
         (vars (remove-duplicates (append (cdr (concept-head concept)) test-vars perc-vars)
                                  :test #'equal))
         (percs (mapcar #'(lambda (var) (let ((temp (assoc var bindings)))
                                          (if (null temp)
                                              (setq flag t) ; when you've got an unbound var
                                              (cdr temp))))
                        vars)))
;;;    (format t "~%test-vars = ~a~%perc-vars = ~a~%vars = ~a~%percs = ~a~%" test-vars perc-vars vars percs)
    (if (null flag)
        (loop for p in percs ; make sure they're all perceptions (not constants or...)
              when (and (not (member p result :test #'equal))
                        (member p pstm* :key #'second))
              collect p into result
              finally (return result))
        ;;;
        ;;; Else all the percs in the world?
        (cons t (copy-list pstm*)))))

(defun get-vars (percept-pattern)
  (loop for item in (cdr percept-pattern)
        if (variablep item)
        collect item))

(defun collect-test-vars (part)         ;;; given a test, return the vars referenced in it
  (loop for piece in part
        if (listp piece) 
        append (collect-test-vars piece)
        if (variablep piece) 
        collect piece))

(defun get-all-percepts (belief)
  ;;; counting on instantiations never being circular in their dependencies
  (let ((pos-deps (remove nil (mapcar #'lookup-belief (cinstance-pos-dependencies belief)))))
    (setf (cinstance-total-percepts belief)
          (remove-duplicates (append (cinstance-percepts belief)
                                     (mapcan #'get-all-percepts pos-deps))
                             :test #'equal))
    (unless (null (cinstance-neg-dependencies belief))
      (push t (cinstance-total-percepts belief)))
    (cinstance-total-percepts belief)))

(defun lookup-belief (belief-head) ; returns a single belief matching the input head
  (let* ((name (car belief-head))
         (concepts (loop for c in cltm* 
                         when (eq name (concept-name c)) 
                         collect c))
         (vars (cdr (concept-head (first concepts))))) ;assumes all concepts w/same name have same args
    (loop for c in concepts
          for beliefs = (concept-instances c)
          for result = (car (member belief-head beliefs :test #'equal :key #'cinstance-head))
          unless (null result) return result)))


(defvar sorted-blocks* nil)

;; Sort-concepts has been changed so that it returns a list of sorted sections of
;; the concept network.  Each section is a list of sorted concepts.
;; The algorithm works by marking the network to find the loops, expanding the loops
;; to catch any duplicates marked from different directions in the search, and to 
;; catch any overlapping loops as actually being the same one.  Then the loops that are
;; large enough are broken into pieces so the straight internal parts of each can be 
;; treated as non-looping.  All the loops (and their pieces) are kept in order for the 
;; final answer that is presented and this ordering is remembered with looped-heads.
(defun sort-concepts ()
  (when (null sorted-blocks*)
    (let* ((temp (get-mapping-id-unprocessed-heads))
           (mapping-id (car temp))
           (unprocessed-heads (cdr temp))
           (concepts cltm*)
           (result nil)
           (rresult nil)
           (loops (mapcar #'flush-concepts (find-loops mapping-id)))
           (looped-concepts (remove-duplicates (apply #'append loops)
                                               :test #'same-concept))
           (looped-heads (mapcar #'concept-name looped-concepts)))
      (setq concepts (set-difference concepts looped-concepts :test #'same-concept))

;;;                                        (format t "~%concepts: ~a~&" concepts)
;;;                                        (format t "~%loops: ~a~&" looped-concepts)

      (do ((current))
          ((and (null concepts)(null loops)) nil)
        (setq current (get-next-concept concepts unprocessed-heads))
        (cond ((null current)
               (let ((next (get-next-loop loops looped-heads unprocessed-heads)))
;;;               (format t "~%Doing null - next-loop: ~a~&" next)
                 (push (reverse result) rresult)
                 (setq result nil)
                 (push next rresult)
                 (setq loops (remove next loops :test #'same-loop))
                 (loop for concept in next
                       for head = (car (concept-head concept))
                       doing (set-ids concept mapping-id)
                       (setq unprocessed-heads (remove head unprocessed-heads)))
                 ))
              (t       
;;;             (format t "~%Doing t - current: ~a~&" current)
               (push current result)
               (setq concepts (remove current concepts)
                     unprocessed-heads (remove (car (concept-head current))
                                               unprocessed-heads 
                                               :count 1 :test #'equal))
               (set-ids current mapping-id))))
      (if (not (null result))
          (push (reverse result) rresult))
      (setq sorted-blocks* (reverse rresult))
      )))

(defun get-next-concept (concepts unprocessed-heads)
  (loop for concept in concepts
        when (check-concept concept unprocessed-heads)
        return concept))

(defun get-next-loop (loops looped-heads unprocessed-heads)
  (setq unprocessed-heads (set-difference unprocessed-heads looped-heads))
  (or (loop for lup in loops
            when (no-dependency lup unprocessed-heads)
            return lup)
      (first loops)))

(defun flush-concepts (lup)
  (loop for concept1 in lup
        append (flush-concept concept1)))

(defun flush-concept (concept) ; brute-force way to get all concepts sharing a name
  (loop for concept2 in cltm*
        if (same-concept concept concept2)
        collect concept2))

(defun no-dependency (lup heads &aux (temp t))
  (loop for concept in lup
        for pos = (mapcar #'car (concept-positives concept))
        for neg = (mapcar #'car (concept-negatives concept))
        if (intersection (union pos neg) heads)
        do (setq temp nil))
  temp)
        
(defun depends-on (concept1 concept2)
  (let ((head (car (concept-head concept1)))
        (subsp (concept-positives concept2))
        (subsn (concept-negatives concept2)))
    (or (member head subsp :key #'car)
        (member head subsn :key #'car))))

(defun get-top-points ()
  (loop for concept in cltm*
        if (not (loop for c in (remove concept cltm*)
                      if (depends-on concept c)
                      return t))
        collect concept))
                   
(defun self-recursive (concept)
  (or (depends-on concept concept)
      (loop for c in (concept-siblings concept) ;last I looked, siblings weren't being maintained
            if (or (depends-on concept c) (depends-on c concept))
            return t)))

(defun get-subs (concept) ;; ==> returns concepts addressed by relations (includes siblings)
  (let ((subsp (mapcar #'car (concept-positives concept)))
        (subsn (mapcar #'car (concept-negatives concept))))
    (remove-duplicates
     (loop for sub in (remove-duplicates (append subsp subsn))
           for ids = (gethash sub concept-name-hash-table*)
           append (mapcar #'lookup ids))
     :test #'same-concept)))

(defun same-loop (cons1 cons2)
  (null (set-difference cons1 cons2 :test #'same-concept)))

;; Loop-points is an alist of (highpoint . lowpoint) in the concept network
(defvar loop-points nil)
(defun find-loops (&optional (mapping-id (car (get-mapping-id-unprocessed-heads))))
  (create-name-hash-table mapping-id) ; Because we need mapping-id
;  (set-skill-id mapping-id)          ; Because we need mapping-id  [ ignore in REWRITE since it breaks with new skills -- is it needed ]
  (create-hash-table)
  (setq loop-points nil)
  (find-points1)
  (setq loop-points (remove-duplicates loop-points :test #'same-loop))
  ;; then join up the overlapping loops
;  (format t "~%~a~&" loop-points)
  (loop for loops = (cdr loop-points)
        for loopie = (car loop-points)
        for overlap = (car (member loopie loops 
                                   :test #'(lambda (list1 list2)
                                             (intersection list1 list2 :test #'same-concept))))
        with temp = nil
        if overlap 
        do (setq loop-points (cons (union loopie overlap :test #'same-concept)
                                   (remove overlap loops)))
        else do (setq loop-points loops)
                (push loopie temp)
        when (null loop-points) return temp))

(defun find-points1 (&optional (concepts (get-top-points)) (seen-before nil))
  (loop for concept in concepts
        for position = (position concept seen-before :test #'same-concept)
;        if (self-recursive concept)
;        do (push (list concept) loop-points)
        if (not (null position))
        do (push (subseq seen-before 0 (1+ position)) loop-points)
        ;; need to recurse even when faced with concepts in seen-before
        else do (find-points1 (get-subs concept) (cons concept seen-before))))



;; For fast-matcher, we need to install the upper-level controller that watches
;; the propagation through the concept network and breaks up the progress so
;; that the unlooped sections of the partially-ordered network happen fast,
;; in order, and only once.  The looped sections of the network are kept in 
;; best order and propagated through the loops as many times as necessary
;; Then the process repeats, doing more unlooped and looped sections of the 
;; network until the whole network is finished.
(defun chooser (concepts perceptions beliefs) ; ignoring concepts
;;;  (initialize-concept-network)
  (sort-concepts)
  (let ((blocks sorted-blocks*))
    (loop until (null blocks)
          do
          (setq concepts (car blocks)
                blocks (cdr blocks))
;;;          (setq beliefs (union (single-infer concepts perceptions beliefs) beliefs))
          (setq beliefs (union (fast-matcher concepts perceptions beliefs) beliefs))

          (setq concepts (car blocks) ; and then run heavy-handed on the recursive loops
                blocks (cdr blocks))
          (setq beliefs (union (infer concepts perceptions beliefs) beliefs))
          ))
  beliefs)

;;; Negations-p usable for checking a loop for negations
(defun negations-p (concepts)           ; not currently used 
  (loop for concept in concepts
        thereis (concept-negatives concept)))

(defun fast-matcher (concepts perceptions beliefs)
  (let ((ccopy concepts)) ; first go fast on the sorted part of the network
    (do ((concept (car ccopy) (car ccopy)))
        ((null ccopy) beliefs)
      (setq beliefs
            (union (match-a-concept concept concepts perceptions) beliefs))
      (pop ccopy))))  



;; Here we change the match-a-concept function so that it produces the new beliefs
;; Also so that it takes the instances from the concept as a starting set of
;; good inferences rather than starting from nil
(defun match-a-concept (concept concepts perceptions)
;  (format t "~2%Match-a-concept: ~a~&" concept)
  (let* ((percepts    (concept-percepts   concept))
         (positives   (concept-positives  concept))
         (negatives   (concept-negatives  concept))
         (tests       (concept-tests      concept))
         (head        (concept-head       concept))
         (pschildren  (concept-pschildren concept))
         (bmatches    (match-positives pschildren positives
				       percepts perceptions nil))
         (nginstances (apply #'append (get-sub-instances (concept-ngchildren concept))))
         (inferences (concept-instances concept)))
    (do ((bindings (car bmatches) (car bmatches)))
        ((null bmatches) (setf (concept-instances concept) inferences))
      (let* ((belief-head (cons (car head) (instantiate-args (cdr head) bindings)))
             )
        (cond ((and (null (member belief-head inferences :test #'equal :key #'cinstance-head))
                    (match-tests tests bindings)
                    (cond ((null negatives) t)
                          (t (none-match negatives nginstances bindings))))
;               (format t "~&...inferring ~a~&" belief-head)
               (push (make-cinstance :head belief-head
                                     :id (concept-id concept)
                                     :bindings bindings ; alist of (var . perc) where perc is from pstm* space
                                     :pos-dependencies (get-pos-sub-heads concept bindings)
                                     :neg-dependencies (get-neg-sub-heads concept bindings)
                                     :percepts (get-percepts concept bindings) ; items from the pstm* space
                                     )
                     inferences)
               (get-all-percepts (car inferences)))
              ))
      (pop bmatches))))


;; RUN-INFERENCE is the single blackbox point-of-contact for anyone making use of the inference engine.
;; It calculates the current cycle's set of beliefs after checking for which set of beliefs 
;; may need recalculating.  The CHOOSER checks between INFER and FAST-MATCHER for the more appropriate one
;; to be using on each section of the concept network.  Finally, the new set of beliefs is returned.
(defun run-inference ()
    (update-beliefs)            ; resets cstm* by deleting bad beliefs
    (setq former-percepts*          ; and set the percs for next cycle
          (if (boundp 'pstm*) (copy-tree pstm*) nil))
    (setq cstm* (chooser cltm* pstm* cstm*)))


(defvar former-percepts* nil)           ;used for comparing new-old for changes

(defun update-beliefs (&aux (kept-beliefs nil) (perc-changes nil) (names nil))
  (when (or (not (boundp 'cstm*)) (null cstm*))
    (setq cstm* nil)
    (return-from update-beliefs))
  (loop for perc in (mapcar #'second (union pstm* former-percepts* :key #'second))
        for old-perc = (car (member perc former-percepts* :key #'second))
        for new-perc = (car (member perc pstm* :key #'second))
        for changep = (equal old-perc new-perc)
        unless (assoc perc perc-changes) ; unless already done
        do (push (cons perc changep) perc-changes))
;  (print perc-changes)
  (setq names (mapcar #'second pstm*))
  (do* ((cb cstm* (cdr cb))
        (belief (car cb) (car cb))
        (count 0 (1+ count)))
       ((null cb) nil)
;    (print (list count belief))
    (cond ;((member belief static-beliefs* :test #'same-cinstance) ; if it's a static belief
	  ; (push belief kept-beliefs)
	  ; (setq cstm* (remove belief cstm*)))
	  ((not (subsetp (cinstance-total-percepts belief) names)) ; if not all percs still exist
;           (print "not all percs exist")
           (delete-belief belief))
          ((loop for perc in (cinstance-total-percepts belief) ; if no change in the important percs 
                 always (cdr (assoc perc perc-changes)))
;           (print "no important percs changed")
           (push belief kept-beliefs)
           (setq cstm* (remove belief cstm*)))
          ((basic-belief-p belief) ; if it's a primary belief (one level above percs)
           (if (tests-valid-p belief pstm* names) ; and the tests are still good
               (let ()
;                 (print "basic belief with good tests")
                 (push belief kept-beliefs)
                 (setq cstm* (remove belief cstm*)))
               (delete-belief belief)))
          (t nil))) ; else it's a higher-level belief, handle it in propagation
  (loop until (null cstm*) ; bottom-up propagation, deleting beliefs that are no longer good
        doing (loop for belief in cstm*
                    ;; when this belief depends on good beliefs and tests are good
                    when (dependency-free belief kept-beliefs)
                    do (if (null (concept-tests (lookup (cinstance-id belief))))
                           (let () 
                             (push belief kept-beliefs)
                             (setq cstm* (remove belief cstm*)))
                           (delete-belief belief))
                    ;; else if it believes in deleted beliefs
                    else do (when (dependencies-deleted-p belief (append kept-beliefs cstm*))
                              (delete-belief belief))))
  (setq cstm* kept-beliefs)
;  (print "Saved beliefs:")
;  (pb)
  )
               
(defun basic-belief-p (belief)
  (null (concept-relations (lookup (cinstance-id belief)))))

(defun tests-valid-p (belief new-percs perc-names)
  ;; retesting is assumed to only happen for lowest-level beliefs
  (let* ((concept (lookup (cinstance-id belief)))
         (bindings (cinstance-bindings belief))
         (tests (concept-tests concept))
         (percepts (concept-percepts concept)))
    ;; resetting the bindings to match new percs
    (setq bindings (remove-if #'(lambda (x) (not (member x perc-names :test #'equal)))
                              bindings :key #'cdr))
    (loop for pattern in percepts
          for name = (cdr (assoc (second pattern) bindings :test #'equal))
          for perc = (car (member name new-percs :key #'second :test #'equal))
          for update = (pmatches pattern perc bindings)
          when (car update)
          do (setq bindings (cdr update))
          else do (return-from tests-valid-p nil))
    (setf (cinstance-bindings belief) bindings) ; set for the new bindings
    ;; then test the new percs with the new bindings
    (match-tests tests bindings)))

(defun dependency-free (belief kept-beliefs)
  (loop for b in (cinstance-pos-dependencies belief)
        never (null (member b kept-beliefs :test #'equal :key #'cinstance-head))))

(defun dependencies-deleted-p (belief beliefs)
  ;; beliefs is a collection of beliefs that have not been deleted
  ;; belief is tested to see if any of its dependencies have been thrown out
  (loop for b in (cinstance-pos-dependencies belief)
        thereis (not (member b beliefs :key #'cinstance-head :test #'equal)))
  )


(defun global-clear-beliefs ()
  (loop for c in cltm*
       doing (mapcar #'delete-belief (concept-instances c)))
  (when (boundp 'cstm*)
    (mapcar #'delete-belief cstm*)))

;;; GAK - match-positives had some bad handling of parentheses that did stuff like
;;; leave variables unbound in confusing ways like using function names as variables
; First match percepts with sub-concept (in positive field only) instances,
; then match perceptions. Delete the matched percept instances and perception
; instances. Then match the rest percepts and perceptions with match-pconds.
; Now concept-rmdup is useless, delete it later
(defun match-positives (pschildren positives percepts perceptions binding)
  (if (null pschildren) 
      (cond ((null percepts) (list binding))
            (t (let ((pmatches (match-pconds percepts perceptions nil binding)))
                 (mapcar #'car pmatches))))
      ;;else
      (let ((all-instances (get-sub-instances pschildren)))
        (unless (member nil all-instances)
          (loop for sub-instance in (car all-instances) 
                appending 
                (match-sub-instance sub-instance pschildren
                                    positives percepts perceptions binding))

          ))))


;; cid-list: list of lists of sub-concept ids
(defun get-sub-instances (cid-list)
  (let ((result nil))
    (do ((cid (car cid-list) (car cid-list))
         (concept nil)
         (sibs nil))
        ((null cid-list) (reverse result))
      (setq concept (lookup cid))
      (setq sibs (loop for cid in (concept-siblings concept)
                       appending (concept-instances (lookup cid))))
      (push (append (concept-instances concept) sibs)
            result)
      (pop cid-list))))


; match-sub-instance
; flag:	 percept name is consistant with the variable in condition, such as
;	 :percept (STREET ?STREET) is consistant with (ON-STREET ?SELF ?STREET)
; flag1: perception is consistant with binding
; flag2: sub-instance is consistant with binding
;	 for example we have :positives ((ABOVE ?ELM1 ?ELM2) (ABOVE ?ELM2 ?ELM3))
;	 then ((ABOVE NUM1 NUM2) (ABOVE NUM3 NUM4)) does not match because of different
;	 values for ?ELM2

(defun match-sub-instance (sub-instance pschildren positives
			   percepts perceptions binding)
  (let* ((args (cinstance-args sub-instance)) ;values 
         ;; assumes all concepts' args show up as vars
         (vars (cdr (concept-head (lookup (cinstance-id sub-instance)))))
         ;; map out the var bindings used for this sub-instance
         (ibinding (mapcar #'cons (cdar positives) args))
         (cross (mapcar #'car (intersection binding ibinding :key #'car))))
    (cond ((/= (length args) (length vars)) nil) ;something bad if this happens
	  (t 
           (when (loop for var in cross ; when there are no conflicting bindings
                       always (equal (cdr (assoc var binding)) 
                                     (cdr (assoc var ibinding))))
             (setq cross (set-difference ibinding binding :test #'equal :key #'car)) 
;;;             (setq binding (union binding ibinding :test #'equal :key #'car))
             (if ; when there's no problem with percepts on new bindings needed
              (loop for (var . value) in cross
                    ;; perception comes out nil if value is a constant, not perception name
                    for perception = (car (member value perceptions :test #'equal :key #'second))
                    for percept = (car (member value percepts :test #'equal :key #'second))
                    for temp = (if (or (null percept) (null perception))
                                   `(t (,var . ,value))
                                   (pmatches1 percept perception binding))
                    unless (null (car temp))
                    do (setq binding (union binding (cdr temp) 
                                            :test #'equal :key #'car))
                    always (or (null percept) 
                               (null perception)
                               (not (null (car temp)))))

              ;;               (loop for percept in percepts
              ;;                     for var = (second percept)
              ;;                     for bond = (assoc var binding)
              ;;                     for perception = (car (member (cdr bond) pstm* :key #'second))
              ;;                     for temp = (if (not (null bond))
              ;;                                    (pmatches1 percept perception binding))
              ;;                     unless (null (car temp))
              ;;                     do (setq binding (union binding (cdr temp) 
              ;;                                             :test #'equal :key #'car))
              ;;                     always (or (null bond) (not (null (car temp)))))
              (match-positives (cdr pschildren) (cdr positives)
                               percepts perceptions binding))))
          )))


;; GAK - checks for constants named in the :percepts field
; PMATCHES inputs a perceptual pattern, a specific perceptual object, and
; a set of bindings (cast as a list of dotted pairs). It returns a list of
; the form (T ((?X . A)(?Y . B))) if the pattern matches and is consistent 
; with the initial bindings and returns a list of the form (NIL ((?X . A)))
; if the match fails or the bindings are inconsistent. 

(defun pmatches (pattern element bindings)
  (cond ((eq (car pattern) (car element))
	 (let* ((pname (cadr pattern))
		(ename (cadr element))
		(nbind (assoc pname bindings))
		(flag t))
	   (cond ((null nbind)
		  ;if the pattern is a variable
		  (if (variablep pname)
		      (push (cons pname ename) bindings)
		    ;if the pattern is a constant
		    ;and the perceptual name is the same as that
		    (if (equal pname ename)
			(push (cons pname ename) bindings)
		      ;if the pattern is a constant
		      ;and the perceptual name does not match
		      (setq flag nil))))
		 ((not (eq (cdr nbind) ename))
		  (setq flag nil)))
	   (setq pattern (cddr pattern))
	   (do ((variable (cadr pattern) (cadr pattern)))
	       ((or (null flag) (null pattern))
		(cons flag bindings))
	       (let ((value (cadr (member (car pattern) element)))
		     (vbind (assoc variable bindings)))
		 (cond ((not (variablep variable))
                        ;;; checks for constants
                        (if (not (equal value variable)) (setq flag nil)))
                       ((null vbind)
			;if the pattern is a variable
			(if (variablep variable)
			    (push (cons variable value) bindings)
			  ;if the pattern is a constant
			  ;and the perceptual name is the same as that
			  (if (equal variable value)
			      (push (cons variable value) bindings)
			    ;if the pattern is a constant
			    ;and the perceptual name does not match
			    (setq flag nil))))
		       ((not (equal (cdr vbind) value))
			(setq flag nil))))
	       (setq pattern (cddr pattern)))))))


;; just needed to include LOOKUP since it wasn't with matcher.lisp
(defun lookup (id)
 (gethash id concept-hash-table*))

; GET-MATCHES incorporated into MATCHER.LISP - Dongkyu

; Changes in RUN-INIT are incorporated into INTERPRETER.LISP,
; using a new function, CLEAR-FAST-MATCHER. - Dongkyu
(defun clear-fast-matcher ()
  (global-clear-beliefs)
  (setq sorted-blocks* nil))